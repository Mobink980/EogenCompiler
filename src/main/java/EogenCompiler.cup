
import java_cup.runtime.*;
import java.io.IOException;
import java.io.File;
import java.io.FileReader;
import models.*;
import helpers.*;

parser code {:
    EogenLexer lexer;
    EogenParser(EogenLexer lexer) { super(lexer); this.lexer = lexer; }
:}

init with {:

:};

scan with {: Symbol token = this.lexer.next_token(); System.out.println("sym : " + token.sym + ", value : " + token.value); return token; :};

terminal SUM, SUBTRACT, MULTIPLY, DIVISION, POWER, MOD, UMINUS, EQUAL, LPAREN, RPAREN, LBRACE, RBRACE, SEMI, COLON, COMMA,
         FOR, IF, ELSE, SWITCH, CASE, WHILE, IS, FOREACH, TRY, CATCH, BASED, ON, BEHAVES, LIKE, CLASS, BEHAVIOUR, FUNCTION,
         OF, INSTANCE, EMPTY, CHAINSIGN, ASSIGN, GT, LT, GE, LE, NE, EXEC, ARROW, ENCAPSULATE, RETURN;
terminal String IDENTIFIER;
terminal Double NUMBER;
terminal String STRING;

nonterminal exp, exp_list, for_exp, foreach_exp, while_exp, if_exp, switch_exp, try_exp, function_exp,
            behaviour_exp, class_exp, elseif_exp, case_exp, arg_list, param_list, param, epsilon, callback_exp;

precedence left EQUAL, GT, LT, GE, LE, NE, ASSIGN, SEMI, COLON, COMMA, ARROW;
precedence left SUM, SUBTRACT;
precedence left MULTIPLY, DIVISION, MOD;
precedence left POWER;
precedence left UMINUS;
precedence left LPAREN, RPAREN, LBRACE, RBRACE;
precedence left FOR, IF, ELSE, SWITCH, CASE, WHILE, IS, FOREACH, TRY, CATCH, BASED, ON, BEHAVES, LIKE, CLASS, BEHAVIOUR,
                FUNCTION, IDENTIFIER, EXEC, ENCAPSULATE, OF, INSTANCE, NUMBER, STRING, EMPTY, CHAINSIGN, RETURN;

// main ----------------------------------------------------------------------------------------------------------------
exp_list ::=
  exp_list:el exp:e1                                                                                          {: :} |
  exp_list:el if_exp:ie                                                                                       {: :} |
  exp_list:el switch_exp:se                                                                                   {: :} |
  exp_list:el for_exp:fe                                                                                      {: :} |
  exp_list:el foreach_exp:fee                                                                                 {: :} |
  exp_list:el while_exp:we                                                                                    {: :} |
  exp_list:el try_exp:te                                                                                      {: :} |
  exp_list:el function_exp:fe                                                                                 {: :} |
  exp_list:el class_exp:ce                                                                                    {: :} |
  exp_list:el behaviour_exp:be                                                                                {: :} |
  exp_list:el RETURN exp:e1                                                                                   {: :} |
  exp:e1                                                                                                      {: :} |
  epsilon:e1                                                                                                  {: :}
;
// class ---------------------------------------------------------------------------------------------------------------
class_exp ::= CLASS IDENTIFIER LBRACE exp_list:el1 RBRACE                                                     {: :} |
              CLASS IDENTIFIER BASED ON IDENTIFIER LBRACE exp_list:el1 RBRACE                                  {: :} |
              CLASS IDENTIFIER BEHAVES LIKE IDENTIFIER LBRACE exp_list:el1 RBRACE                               {: :} |
              CLASS IDENTIFIER BASED ON IDENTIFIER BEHAVES LIKE IDENTIFIER LBRACE exp_list:el1 RBRACE            {: :}
;
// behaviour -----------------------------------------------------------------------------------------------------------
behaviour_exp ::= BEHAVIOUR IDENTIFIER LBRACE exp_list:el1 RBRACE                                             {: :}
;
// function ------------------------------------------------------------------------------------------------------------
function_exp ::= FUNCTION IDENTIFIER LPAREN RPAREN LBRACE exp_list:el RBRACE                                     {: :} |
                 FUNCTION IDENTIFIER LPAREN IDENTIFIER RPAREN LBRACE exp_list:el RBRACE                          {: :} |
                 FUNCTION IDENTIFIER LPAREN IDENTIFIER arg_list:al1 RPAREN LBRACE exp_list:el RBRACE             {: :} |
                 FUNCTION IDENTIFIER LPAREN RPAREN OF CLASS LBRACE exp_list:el RBRACE                            {: :} |
                 FUNCTION IDENTIFIER LPAREN IDENTIFIER RPAREN OF CLASS LBRACE exp_list:el RBRACE                 {: :} |
                 FUNCTION IDENTIFIER LPAREN IDENTIFIER arg_list:al1 RPAREN OF CLASS LBRACE exp_list:el RBRACE    {: :} |
                 FUNCTION IDENTIFIER LPAREN RPAREN OF INSTANCE LBRACE exp_list:el RBRACE                         {: :} |
                 FUNCTION IDENTIFIER LPAREN IDENTIFIER RPAREN OF INSTANCE LBRACE exp_list:el RBRACE              {: :} |
                 FUNCTION IDENTIFIER LPAREN IDENTIFIER arg_list:al1 RPAREN OF INSTANCE LBRACE exp_list:el RBRACE {: :}
;
callback_exp ::= ENCAPSULATE LPAREN RPAREN ARROW LBRACE exp_list:el RBRACE                                       {: :} |
                 ENCAPSULATE LPAREN IDENTIFIER arg_list:al1 RPAREN ARROW LBRACE exp_list:el RBRACE               {: :} |
                 ENCAPSULATE LPAREN IDENTIFIER RPAREN ARROW LBRACE exp_list:el RBRACE               {: :}
;
arg_list ::= COMMA IDENTIFIER arg_list                                                                           {: :} |
             COMMA IDENTIFIER                                                                                    {: :}
;
// empty expression ----------------------------------------------------------------------------------------------------
epsilon ::= ;
// try-catch -----------------------------------------------------------------------------------------------------------
try_exp ::= TRY LBRACE exp_list:el1 RBRACE CATCH LPAREN exp:e1 RPAREN LBRACE exp_list:el2 RBRACE              {: :}
;
// loop ----------------------------------------------------------------------------------------------------------------
for_exp ::= FOR LPAREN exp:e1 SEMI exp:e2 SEMI exp:e3 RPAREN LBRACE exp_list:el1 RBRACE                       {: :}
;
foreach_exp ::= FOREACH LPAREN exp:e1 COLON exp:e2 RPAREN LBRACE exp_list:el RBRACE                           {: :}
;
while_exp ::= WHILE LPAREN exp:e1 RPAREN LBRACE exp_list:el RBRACE                                            {: :}
;
// conditionals --------------------------------------------------------------------------------------------------------
elseif_exp ::= elseif_exp:ei ELSE IF LPAREN exp:e2 RPAREN LBRACE exp_list:el RBRACE                           {: :} |
               ELSE IF LPAREN exp:e2 RPAREN LBRACE exp_list:el RBRACE                                         {: :}
;
if_exp ::= IF LPAREN exp:e1 RPAREN LBRACE exp_list:el1 RBRACE                                                 {: :} |
           IF LPAREN exp:e1 RPAREN LBRACE exp_list:el1 RBRACE ELSE LBRACE exp_list:el2 RBRACE                 {: :} |
           IF LPAREN exp:e1 RPAREN LBRACE exp_list:el1 RBRACE elseif_exp:eie1                                 {: :} |
           IF LPAREN exp:e1 RPAREN LBRACE exp_list:el1 RBRACE elseif_exp:eie1 ELSE LBRACE exp_list:el2 RBRACE {: :}
;
case_exp ::= case_exp:ce CASE exp:e1 COLON LBRACE exp_list:el RBRACE                                          {: :} |
             CASE exp:e1 COLON LBRACE exp_list:el RBRACE                                                      {: :}
;
switch_exp ::= SWITCH LPAREN exp:e1 RPAREN LBRACE case_exp:ce RBRACE                                          {: :}
;
// math ----------------------------------------------------------------------------------------------------------------
exp ::= exp:e1 IS exp:e2                         {: :} |
        exp:e1 EQUAL exp:e2                      {: :} |
        exp:e1 GE exp:e2                         {: :} |
        exp:e1 GT exp:e2                         {: :} |
        exp:e1 LT exp:e2                         {: :} |
        exp:e1 LE exp:e2                         {: :} |
        exp:e1 NE exp:e2                         {: :} |
        IDENTIFIER ASSIGN exp:e1                 {: :} |
        IDENTIFIER ASSIGN function_exp           {: :} |
        EXEC IDENTIFIER LPAREN param_list:pl1 RPAREN  {: :} |
        EXEC exp:e1 CHAINSIGN IDENTIFIER LPAREN param_list:pl1 RPAREN  {: :} |
        EXEC exp:e1 CHAINSIGN IDENTIFIER LPAREN RPAREN  {: :} |
        exp:e1 SUM exp:e2
                 {:
                     Codes.MathExpSum r = new Codes.MathExpSum();
                     r.setValue1((Codes.Code)e1);
                     r.setValue2((Codes.Code)e2);
                     RESULT = r;
                 :} |
        exp:e1 SUBTRACT exp:e2
                 {:
                     Codes.MathExpSubstract r = new Codes.MathExpSubstract();
                     r.setValue1((Codes.Code)e1);
                     r.setValue2((Codes.Code)e2);
                     RESULT = r;
                 :} |
        exp:e1 MULTIPLY exp:e2
                 {:
                     Codes.MathExpMultiply r = new Codes.MathExpMultiply();
                     r.setValue1((Codes.Code)e1);
                     r.setValue2((Codes.Code)e2);
                     RESULT = r;
                 :} |
        exp:e1 DIVISION exp:e2
                 {:
                     Codes.MathExpDivision r = new Codes.MathExpDivision();
                     r.setValue1((Codes.Code)e1);
                     r.setValue2((Codes.Code)e2);
                     RESULT = r;
                 :} |
        exp:e1 MOD exp:e2
                 {:
                     Codes.MathExpMod r = new Codes.MathExpMod();
                     r.setValue1((Codes.Code)e1);
                     r.setValue2((Codes.Code)e2);
                     RESULT = r;
                 :} |
        exp:e1 POWER exp:e2
                 {:
                     Codes.MathExpPower r = new Codes.MathExpPower();
                     r.setValue1((Codes.Code)e1);
                     r.setValue2((Codes.Code)e2);
                     RESULT = r;
                 :} |
        SUBTRACT exp:e
                 {:
                     Codes.MathExpUminus r = new Codes.MathExpUminus();
                     r.setValue((Codes.Code)e);
                     RESULT = r;
                 :} %prec UMINUS |
        exp:e1 CHAINSIGN exp:e2
                 {:
                     Codes.Chains r = new Codes.Chains();
                     r.setCode1((Codes.Code)e1);
                     r.setCode2((Codes.Code)e2);
                     RESULT = r;
                 :} |
        LPAREN exp:e RPAREN
                 {:
                     Codes.Parenthesis p = new Codes.Parenthesis();
                     p.setCode((Codes.Code)e);
                     RESULT = p;
                 :} |
        callback_exp:ce
                 {:
                     RESULT = (Codes.Code)ce;
                 :} |
        IDENTIFIER:i
                 {:
                     RESULT = (Codes.Code)i;
                 :} |
        NUMBER:n
                 {:
                     Codes.Value v = new Codes.Value();
                     v.setValue(n);
                     RESULT = v;
                 :} |
        STRING:s
                 {:
                     Codes.Value v = new Codes.Value();
                     v.setValue(s);
                     RESULT = v;
                 :} |
        EMPTY
                 {:
                     Codes.Value v = new Codes.Value();
                     v.setValue(null);
                     RESULT = v;
                 :}
;
param_list ::= param:p1 COMMA param_list:pl1
                 {:
                     Hashtable<String, Codes.Code> ht = pl1;
                     castedP1 = (Pair<String, Codes.Code>)p1;
                     ht.put(castedP1.first, castedP1.second);
                     RESULT = ht;
                 :} |
               param:p1
                 {:
                     Hashtable<String, Code> ht = new Hashtable<String, Codes.Code>();
                     castedP1 = (Pair<String, Codes.Code>)p1;
                     ht.put(castedP1.first, castedP1.second);
                     RESULT = ht;
                 :} |
               epsilon
                 {:
                     RESULT = new Hashtable<String, Code>();
                 :}
;
param ::= IDENTIFIER:i COLON exp:e1
                 {:
                     RESULT = new Pair<String, Codes.Code>(i, (Codes.Code)e1);
                 :}
;